name: CI/CD
on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
jobs:
  test-ml-client:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v2
    
    - name: Set up Python
      uses: actions/setup-python@v2
      with:
        python-version: '3.10'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        cd machine-learning-client
        if [ -f requirements.txt ]; then pip install -r requirements.txt; fi
        pip install pytest pytest-cov
    
    - name: Test with pytest
      run: |
        cd machine-learning-client
        pytest test_client.py --cov=. --cov-report=xml
    
    - name: Upload coverage report
      uses: codecov/codecov-action@v1
      with:
        file: ./machine-learning-client/coverage.xml
        flags: mlclient
        fail_ci_if_error: false

  test-web-app:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v2
    
    - name: Set up Python
      uses: actions/setup-python@v2
      with:
        python-version: '3.10'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        cd web-app
        if [ -f requirements.txt ]; then pip install -r requirements.txt; fi
        if [ -f requirements-test.txt ]; then pip install -r requirements-test.txt; fi
        pip install pytest pytest-flask pytest-cov
    
    - name: Create Mock MongoDB Connection
      run: |
        cd web-app
        
        # Create a mock_mongo.py file
        cat > mock_mongo.py << 'EOF'
        """MongoDB mocking for tests"""
        from unittest.mock import MagicMock
        import pymongo
        import sys
        
        # Create mock classes for MongoDB errors
        class MockConnectionFailure(Exception):
            pass
        
        class MockServerSelectionTimeoutError(Exception):
            pass
        
        class MockOperationFailure(Exception):
            pass
        
        # Add these errors to pymongo.errors
        pymongo.errors.ConnectionFailure = MockConnectionFailure
        pymongo.errors.ServerSelectionTimeoutError = MockServerSelectionTimeoutError
        pymongo.errors.OperationFailure = MockOperationFailure
        
        # Create a mock MongoClient class
        class MockMongoClient:
            ConnectionFailure = MockConnectionFailure
            ServerSelectionTimeoutError = MockServerSelectionTimeoutError
            OperationFailure = MockOperationFailure
            
            def __init__(self, *args, **kwargs):
                self.admin = MagicMock()
                self.admin.command.return_value = True
            
            def __getitem__(self, name):
                db = MagicMock()
                db.__getitem__.return_value = MagicMock()
                return db
                
            def close(self):
                pass
        
        # Override pymongo.MongoClient with our mock
        pymongo.MongoClient = MockMongoClient
        
        print("MongoDB has been successfully mocked")
        EOF
        
        # Create environment file
        echo "TESTING=True" > .env
        echo "SECRET_KEY=test_key" >> .env
        
        # Create directory for ML model files if needed
        mkdir -p dummy_models
        touch dummy_models/cnn_model.h5
        touch dummy_models/cnn_label_encoder.pkl
        echo "MODEL_PATH=dummy_models/cnn_model.h5" >> .env
        echo "ENCODER_PATH=dummy_models/cnn_label_encoder.pkl" >> .env
    
    - name: Test with pytest
      env:
        TESTING: 'True'
        PYTHONPATH: ${{ github.workspace }}/web-app
      run: |
        cd web-app
        # Import the mock MongoDB before running tests
        python -c "import mock_mongo; print('Mock loaded successfully')"
        
        # Run specific test files instead of discovering
        python -m pytest app_test.py test_routes.py test_ml.py -v --cov=. --cov-report=xml
    
    - name: Upload coverage report
      uses: codecov/codecov-action@v1
      with:
        file: ./web-app/coverage.xml
        flags: webapp
        fail_ci_if_error: false
